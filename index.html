<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HTML5 Tetris</title>
    <style>
        body {
            background-color: #202028;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* Prevent browser zooming/scrolling */
        }

        #game-container {
            position: relative;
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            background-color: #000;
        }

        /* UI Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .hidden { display: none !important; }

        h1 { margin: 0 0 20px 0; font-size: 40px; text-transform: uppercase; letter-spacing: 2px; color: #00f0ff; text-shadow: 0 0 10px #00f0ff; }
        p { font-size: 18px; margin-bottom: 30px; color: #ccc; }
        
        button {
            background: #00f0ff;
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            text-transform: uppercase;
            box-shadow: 0 0 10px #00f0ff;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        /* Score Display */
        #score-board {
            position: absolute;
            top: 10px;
            right: 10px;
            text-align: right;
            pointer-events: none;
        }
        .score-label { font-size: 12px; color: #888; }
        .score-val { font-size: 24px; font-weight: bold; color: #fff; }

        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Hidden on desktop by default, shown via JS if touch detected */
            width: 100%;
            max-width: 400px;
            margin-top: 20px;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            user-select: none;
        }
        .control-btn:active { background: rgba(255, 255, 255, 0.3); }
        .d-pad { display: flex; gap: 10px; }
        .action-pad { display: flex; gap: 10px; }

        /* Show mobile controls on small screens */
        @media (max-height: 800px), (max-width: 600px) {
            #mobile-controls { display: flex; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="tetris" width="240" height="400"></canvas>
        
        <div id="score-board">
            <div class="score-label">SCORE</div>
            <div id="score" class="score-val">0</div>
            <div class="score-label" style="margin-top: 10px;">HIGH SCORE</div>
            <div id="high-score" class="score-val">0</div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="overlay">
            <h1>TETRIS</h1>
            <p>Arrow Keys or Buttons to Move</p>
            <button onclick="startGame()">Play</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="overlay hidden">
            <h1 style="color: #ff0055; text-shadow: 0 0 10px #ff0055;">Game Over</h1>
            <p>Final Score: <span id="final-score">0</span></p>
            <button onclick="resetGame()">Try Again</button>
        </div>
    </div>

    <!-- On-screen controls for mobile -->
    <div id="mobile-controls">
        <div class="d-pad">
            <div class="control-btn" id="btn-left">←</div>
            <div class="control-btn" id="btn-down">↓</div>
            <div class="control-btn" id="btn-right">→</div>
        </div>
        <div class="action-pad">
            <div class="control-btn" id="btn-rotate" style="border-color: #00f0ff; color: #00f0ff;">↻</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score');
        const finalScoreElement = document.getElementById('final-score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');

        // --- Game Constants ---
        const ROW = 20;
        const COL = 10;
        let SQ = 20; // Initial square size, will be calculated dynamically
        const VACANT = "#111"; // Empty square color

        // --- The Tetrominoes (Shapes) ---
        // Defined as matrices where 1 is part of the piece
        const PIECES = [
            [Z, "#ff0055"],
            [S, "#00ff99"],
            [T, "#bf00ff"],
            [O, "#ffff00"],
            [L, "#ffaa00"],
            [I, "#00f0ff"],
            [J, "#0055ff"]
        ];

        // Shape Definitions
        function Z() { return [[[1,1,0],[0,1,1],[0,0,0]]]; }
        function S() { return [[[0,1,1],[1,1,0],[0,0,0]]]; }
        function T() { return [[[0,1,0],[1,1,1],[0,0,0]]]; }
        function O() { return [[[1,1],[1,1]]]; }
        function L() { return [[[0,0,1],[1,1,1],[0,0,0]]]; }
        function I() { return [[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]]; }
        function J() { return [[[1,0,0],[1,1,1],[0,0,0]]]; }

        // --- Game State Variables ---
        let board = [];
        let score = 0;
        let highScore = localStorage.getItem('tetris_highscore') || 0;
        let gameRunning = false;
        let dropStart = Date.now();
        let gameOver = false;
        let p; // The current piece

        highScoreElement.innerText = highScore;

        // --- Responsive Canvas ---
        function resizeGame() {
            // Calculate square size based on viewport height to fit the game
            // We want the game to take up about 70-80% of the screen height
            const availableHeight = window.innerHeight * 0.8;
            const availableWidth = window.innerWidth * 0.9;
            
            // SQ = available height / 20 rows
            SQ = Math.floor(availableHeight / ROW);
            
            // Ensure it fits width-wise too
            if (SQ * COL > availableWidth) {
                SQ = Math.floor(availableWidth / COL);
            }

            canvas.width = SQ * COL;
            canvas.height = SQ * ROW;
            
            // Redraw if game isn't running to show grid
            if (!gameRunning && !gameOver) {
                drawBoard();
            }
        }
        window.addEventListener('resize', resizeGame);
        resizeGame(); // Initial call

        // --- Core Functions ---

        // Initialize board
        function createBoard() {
            board = [];
            for(let r = 0; r < ROW; r++){
                board[r] = [];
                for(let c = 0; c < COL; c++){
                    board[r][c] = VACANT;
                }
            }
        }

        // Draw a single square
        function drawSquare(x, y, color){
            context.fillStyle = color;
            context.fillRect(x*SQ, y*SQ, SQ, SQ);

            // Add a bevel effect
            if (color !== VACANT) {
                context.strokeStyle = "rgba(0,0,0,0.3)";
                context.lineWidth = 2;
                context.strokeRect(x*SQ, y*SQ, SQ, SQ);
                
                // Shine
                context.fillStyle = "rgba(255,255,255,0.1)";
                context.fillRect(x*SQ, y*SQ, SQ, SQ/2);
            } else {
                context.strokeStyle = "#222"; // Grid lines
                context.strokeRect(x*SQ, y*SQ, SQ, SQ);
            }
        }

        // Draw the board
        function drawBoard(){
            for(let r = 0; r < ROW; r++){
                for(let c = 0; c < COL; c++){
                    drawSquare(c, r, board[r][c]);
                }
            }
        }

        // The Piece Class
        class Piece {
            constructor(tetromino, color){
                this.tetromino = tetromino; // The shape function
                this.tetrominoN = 0; // Rotation index
                this.activeTetromino = this.tetromino()[this.tetrominoN] || this.tetromino();
                if (Array.isArray(this.activeTetromino[0]) && Array.isArray(this.activeTetromino[0][0])) {
                     // Handle weird nesting if strict mode causes issues, though standard logic above usually works
                     // This is a safety fallback for shape definitions
                     this.activeTetromino = this.activeTetromino[0]; 
                }
                
                // Correction for the array shape structure
                // We passed a function returning [matrix], so we need the matrix
                this.matrix = this.tetromino()[0]; 
                
                this.color = color;
                this.x = 3;
                this.y = -2; // Start slightly above board
            }

            // Fill function
            fill(color){
                for(let r = 0; r < this.matrix.length; r++){
                    for(let c = 0; c < this.matrix.length; c++){
                        if(this.matrix[r][c]){
                            drawSquare(this.x + c, this.y + r, color);
                        }
                    }
                }
            }

            // Draw piece
            draw(){
                this.fill(this.color);
            }

            // Undraw piece
            unDraw(){
                this.fill(VACANT);
            }

            // Move Down
            moveDown(){
                if(!this.collision(0, 1, this.matrix)){
                    this.unDraw();
                    this.y++;
                    this.draw();
                } else {
                    // We hit something, lock piece and generate new one
                    this.lock();
                    if (!gameOver) p = randomPiece();
                }
            }

            // Move Right
            moveRight(){
                if(!this.collision(1, 0, this.matrix)){
                    this.unDraw();
                    this.x++;
                    this.draw();
                }
            }

            // Move Left
            moveLeft(){
                if(!this.collision(-1, 0, this.matrix)){
                    this.unDraw();
                    this.x--;
                    this.draw();
                }
            }

            // Rotate
            rotate(){
                // Transpose + Reverse to rotate matrix
                let nextPattern = this.matrix[0].map((val, index) => this.matrix.map(row => row[index]).reverse());
                
                // Wall kick (basic): if rotation puts us in a wall, don't rotate
                let kick = 0;
                
                if(this.collision(0, 0, nextPattern)){
                    if(this.x > COL/2){
                        // Try moving left
                        kick = -1; 
                    } else {
                        // Try moving right
                        kick = 1;
                    }
                }
                
                if(!this.collision(kick, 0, nextPattern)){
                    this.unDraw();
                    this.x += kick;
                    this.matrix = nextPattern;
                    this.draw();
                }
            }

            // Collision Detection
            collision(x, y, piece){
                for(let r = 0; r < piece.length; r++){
                    for(let c = 0; c < piece.length; c++){
                        // if the square is empty, we skip it
                        if(!piece[r][c]){
                            continue;
                        }
                        
                        // coordinates of the piece after movement
                        let newX = this.x + c + x;
                        let newY = this.y + r + y;
                        
                        // Conditions
                        if(newX < 0 || newX >= COL || newY >= ROW){
                            return true;
                        }
                        
                        // Skip checking negative Y (above board)
                        if(newY < 0){
                            continue;
                        }
                        
                        // Check if there is a locked piece on the board
                        if(board[newY][newX] != VACANT){
                            return true;
                        }
                    }
                }
                return false;
            }

            // Lock Piece
            lock(){
                for(let r = 0; r < this.matrix.length; r++){
                    for(let c = 0; c < this.matrix.length; c++){
                        if(!this.matrix[r][c]){
                            continue;
                        }
                        // pieces to lock on top = game over
                        if(this.y + r < 0){
                            gameOver = true;
                            endGame();
                            return; // Stop processing
                        }
                        // Lock the piece
                        board[this.y + r][this.x + c] = this.color;
                    }
                }
                
                // Remove full rows
                let rowsCleared = 0;
                for(let r = 0; r < ROW; r++){
                    let isRowFull = true;
                    for(let c = 0; c < COL; c++){
                        if(board[r][c] == VACANT) { 
                            isRowFull = false;
                            break;
                        }
                    }
                    if(isRowFull){
                        rowsCleared++;
                        // Move all rows above down
                        for(let y = r; y > 1; y--){
                            for(let c = 0; c < COL; c++){
                                board[y][c] = board[y-1][c];
                            }
                        }
                        // Top row is now empty
                        for(let c = 0; c < COL; c++){
                            board[0][c] = VACANT;
                        }
                    }
                }
                
                // Scoring: 10, 30, 60, 100 based on lines
                if (rowsCleared > 0) {
                    const points = [0, 10, 30, 60, 100];
                    score += points[rowsCleared] || 100;
                    scoreElement.innerText = score;
                }

                drawBoard();
            }
        }

        // Generate Random Piece
        function randomPiece(){
            let r = Math.floor(Math.random() * PIECES.length);
            return new Piece(PIECES[r][0], PIECES[r][1]);
        }

        // --- Game Control ---

        function drop(){
            if(gameOver || !gameRunning) return;
            
            let now = Date.now();
            let delta = now - dropStart;
            
            // Speed increases slightly as score goes up (simple curve)
            let speed = Math.max(200, 1000 - (score * 2));
            
            if(delta > speed){
                p.moveDown();
                dropStart = Date.now();
            }
            
            requestAnimationFrame(drop);
        }

        function startGame() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            createBoard();
            drawBoard();
            score = 0;
            scoreElement.innerText = score;
            gameRunning = true;
            gameOver = false;
            p = randomPiece();
            dropStart = Date.now();
            drop();
        }

        function resetGame() {
            startGame();
        }

        function endGame() {
            gameRunning = false;
            finalScoreElement.innerText = score;
            if(score > highScore) {
                highScore = score;
                localStorage.setItem('tetris_highscore', highScore);
                highScoreElement.innerText = highScore;
            }
            gameOverScreen.classList.remove('hidden');
        }

        // --- Inputs ---

        // Keyboard
        document.addEventListener("keydown", function(event){
            if(!gameRunning) return;
            
            if(event.keyCode == 37){
                p.moveLeft();
            }else if(event.keyCode == 38){
                p.rotate();
                // prevent scrolling
                event.preventDefault(); 
            }else if(event.keyCode == 39){
                p.moveRight();
            }else if(event.keyCode == 40){
                p.moveDown();
                // prevent scrolling
                event.preventDefault();
            }
        });

        // Touch / Mouse for On-Screen Buttons
        const setupBtn = (id, action) => {
            const btn = document.getElementById(id);
            // Handle both click and touch to be safe
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // prevent zoom/scroll
                if(gameRunning) action();
            });
            btn.addEventListener('mousedown', (e) => {
                if(gameRunning) action();
            });
        };

        setupBtn('btn-left', () => p.moveLeft());
        setupBtn('btn-right', () => p.moveRight());
        setupBtn('btn-rotate', () => p.rotate());
        
        // Fast drop for down button
        const downBtn = document.getElementById('btn-down');
        let downInterval;
        
        const startDown = (e) => {
            if(e.cancelable) e.preventDefault();
            if(!gameRunning) return;
            p.moveDown(); // Move once immediately
            downInterval = setInterval(() => {
                if(gameRunning && !gameOver) p.moveDown();
            }, 100);
        }
        
        const stopDown = (e) => {
            if(e.cancelable) e.preventDefault();
            clearInterval(downInterval);
        }

        downBtn.addEventListener('touchstart', startDown);
        downBtn.addEventListener('touchend', stopDown);
        downBtn.addEventListener('mousedown', startDown);
        downBtn.addEventListener('mouseup', stopDown);
        downBtn.addEventListener('mouseleave', stopDown);

        // Initial draw
        createBoard();
        drawBoard();

    </script>
</body>
</html>

